Овсяников А.А., ИУ10-36 (вариант №9)

1.1 Постоянная функция:

        В случае постоянной функции f(v) = N, где N - это константа (например, f([1, 2, 3]) = 11, f([0, 1, 100]) = 11, f([1101]) = 11 и так далее),
        временная сложность всегда остается постоянной и не зависит от размера входных данных.
        Функция f(v) всегда выполняется за одно и то же количество операций, независимо от значения v или размера данных.
        Поэтому временная сложность такой функции всегда равна O(1) или просто константе.

        Анализ графика (constant_time.png), отражающего зависимость постоянной функции от n,
        подтвердил вышесказанное - временная сложность постоянной функции равна O(1).
        Скачки на графике могли быть вызваны различными факторами, в том числе фоновыми процессами системы.

1.2 Вычисление полинома методом Горнера:

        F(v) = v1 + x * (v2 + x * (v3 + ...))
        Временная сложность вычисления полинома методом Горнера составляет O(n), где n - степень полинома.
        Этот алгоритм выполняет n умножений и n сложений, что делает его линейным по отношению к степени полинома,
        то есть при увеличении степени полинома на единицу, количество действий, необходимых для его вычисления, также увеличивается на постоянную величину.

        По графику (horner_pol.png) видно, что время выполнения алгоритма растет линейно с увеличением размера входных данных (в данном случае, степени полинома).
        Таким образом, и эмперический анализ показал, что временная сложность вычисления полинома методом Горнера составляет O(n).

1.3 Поиск максимума простым перебором:

        Инициализация переменной max_value происходит один раз и занимает постоянное время O(1).
        Проход по всем элементам вектора vector выполняется в цикле. В худшем случае, алгоритм должен пройти через каждый элемент вектора.
        Таким образом, количество итераций цикла будет равно длине вектора n, где n - это количество элементов в векторе.
        Внутри цикла выполняется проверка условия if value > max_value, которая также занимает постоянное время O(1).

        Итак, общая временная сложность этого алгоритма будет O(n), где n - это количество элементов в векторе.
        Это означает, что время выполнения алгоритма линейно зависит от размера входного вектора.

        График (max.png) демонстрирует линейную зависимость времени выполнения алгоритма от размера входного вектора.
        Следовательно, сложность этого алгоритма - O(n).

1.4 Поиск среднего арифметического:

        Суммирование всех элементов вектора (sum(vector)): Суммирование всех элементов вектора требует времени, пропорционального количеству элементов в векторе (n). (Сложность этой операции - O(n))
        Определение длины вектора (len(vector)): Операция также требует времени, пропорционального количеству элементов в векторе (n). (O(n))
        Деление суммы на количество элементов: Операция выполняется во времени, не зависящем от размера вектора. (O(1))

        Таким образом, временная сложность поиска среднего арифметического вектора - O(n), где n - количество элементов в векторе.

        К тем же результатам приходим и после анализа графика (average_value.png) зависимости времени поиска среднего арифметического от n.

2. Обычное матричное произведение:

        Пусть даны две квадратные матрицы размером n x n, которые необходимо перемножить (С = A x B):

        Для каждого элемента результата C[i][j], который находится в i-й строке и j-м столбце, мы выполняем n умножений и n-1 сложений.
        Всего элементов в результирующей матрице n x n.
        Следовательно, общее количество умножений и сложений для обычного матричного произведения составляет: n * (n * n-1) = n^2 * (n-1) операций.
        Это можно записать как O(n^3) операций в силу при асимптотического поведения.

        График, отражающий зависимость времени выполнения матричного умножения от n, (matrix_multiply.png) подтверждает выводы теоретического анализа - временная сложность алгоритма равна O(n^3).